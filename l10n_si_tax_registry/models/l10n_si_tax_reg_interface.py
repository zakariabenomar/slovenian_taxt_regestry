# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import logging
import re

from odoo import api, exceptions, fields, models
import odoo.addons.decimal_precision as dp
from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT as DATETIME_FORMAT
from odoo.tools import float_round
from odoo.tools.translate import _

from .. SITaxReg.SITaxReg import SITaxReg
from .. TmpCert.TmpCert import TmpCert

_ODOO_TAX_TYPE_2_SI_TAX_TYPE = {
    'regular': ('VAT', ('TaxRate', 'TaxableAmount', 'TaxAmount')),
    'flat': ('FlatRateCompensation', ('FlatRateRate', 'FlatRateTaxableAmount', 'FlatRateAmount')),
    'other': ('OtherTaxesAmount', ()),
    'exempt': ('ExemptVATTaxableAmount', ()),
    'reverse': ('reverseVATTaxableAmount', ()),
    'notax': ('NontaxableAmount', ()),
    'special': ('SpecialTaxRulesAmount', ()),
}
_ODOO_TAX_TYPE_2_SI_TAX_TYPE[''] = _ODOO_TAX_TYPE_2_SI_TAX_TYPE['regular']

_logger = logging.getLogger(__name__)

def _resolve_many_2_one_field(rec, fields):
    if '.' in fields:
        fields = fields.split('.')
        rec = rec[fields[0]]
        fields = fields[1:]
        for f in fields:
            rec = rec[f]

        return rec

    return rec[fields]

class L10nSiTaxRegInterface(models.AbstractModel):
    _name = 'l10n_si_tax_reg.interface'

    _l10n_si_tax_reg_issue_datetime = ''
    _l10n_si_tax_reg_customer_tax = ''
    _l10n_si_tax_reg_value_invoice = ''
    _l10n_si_tax_reg_payment_invoice = ''
    _l10n_si_tax_reg_behalf_invoice = ''
    _l10n_si_tax_reg_taxes = ''
    _l10n_si_tax_reg_issuer_invoice = ''
    _l10n_si_tax_reg_msg_invoice = ''
    _l10n_si_tax_reg_currency = ''
    _l10n_si_tax_reg_date_debt = ''

    _l10n_si_tax_reg_refund_negate = True
    _l10n_si_tax_reg_value_returns_inc_invoice = False
    _l10n_si_tax_reg_payment_returns_inc_invoice = True

    _l10n_si_tax_reg_module_name = ''
    _l10n_si_tax_reg_view_action = ''
    _l10n_si_tax_reg_paid_state_field = 'state'
    _l10n_si_tax_reg_paid_state_value = ''

    @api.model
    def _default_l10n_si_tax_reg_premise_line_id(self):
        #res = self.env['ir.values'].get_default('l10n_si_tax_reg.interface', 'l10n_si_tax_reg_premise_line_id', company_id=self.env.user.company_id.id)
        res = self.env['ir.default'].get('l10n_si_tax_reg.interface', 'l10n_si_tax_reg_premise_line_id', company_id=self.env.user.company_id.id)
        return isinstance(res, list) and res[0] or res or self.env['l10n_si_tax_reg.premise.line']

    @api.model
    def _default_l10n_si_tax_reg_force_sent(self):
        #res = self.env['ir.values'].get_default('l10n_si_tax_reg.interface', 'l10n_si_tax_reg_force_sent', company_id=self.env.user.company_id.id)
        res = self.env['ir.default'].get('l10n_si_tax_reg.interface', 'l10n_si_tax_reg_force_sent', company_id=self.env.user.company_id.id)
        return isinstance(res, bool) and res or False

    l10n_si_tax_reg_premise_line_id = fields.Many2one('l10n_si_tax_reg.premise.line', 'Electronic Device', ondelete='set null', default=_default_l10n_si_tax_reg_premise_line_id)

    l10n_si_tax_reg_msg_ident = fields.Char(string='Message Identification', size=32, readonly=True, copy=False,
        help='Identification of the message that was used to send the invoice information to the registry.')
    l10n_si_tax_reg_msg_dt = fields.Datetime(string='Message Time', readonly=True, copy=False,
        help='Sending date and time of the message that was used to send the invoice information to the registry.')

    l10n_si_tax_reg_premise = fields.Char(string='Business Premise', size=20, readonly=True, copy=False,
        help='Name of the location where the invoice has been issued.')
    l10n_si_tax_reg_device = fields.Char(string='Electronic Device', size=20, readonly=True, copy=False,
        help='Electronic device used to issue the invoice.')
    l10n_si_tax_reg_number = fields.Char(string='Si. Tax Registry Invoice Number', size=20, readonly=True, copy=False)
    l10n_si_tax_reg_zoi = fields.Char(string='Issuer Protected ID', size=32, readonly=True, copy=False,
        help='Calculated issuer protective mark generated upon invoice payment.')
    l10n_si_tax_reg_eor = fields.Char(string='Protected ID', size=36, readonly=True, copy=False,
        help='Calculated protective mark generated by slovenian tax registry upon successful invoice submission.')
    l10n_si_tax_reg_force_sent = fields.Boolean(string='Force Sent', default=_default_l10n_si_tax_reg_force_sent,
        help='Check this field to mark this invoice as registered even if an error occurs during the registration phase.')
    l10n_si_tax_reg_sent = fields.Boolean(string='Sent', readonly=True, copy=False,
        help='Has the invoice been registered')
    l10n_si_tax_reg_num_copy = fields.Integer(string='No. of Copies', readonly=True, default=-2, copy=False,
        help='Number of printed copies that have been made for this document. ' +
             'It is assumed that the first two are originals (you hold on to ' +
             'one printed invoice for archival purposes, while the other is handed ' +
             'out to the customer). Every print after those is considered as a copy and ' +
             'should have its copy number appropriately labeled.')

    l10n_si_tax_reg_premise_ref = fields.Char(string='Refund Business Premise', size=20, readonly=True, copy=False)
    l10n_si_tax_reg_device_ref = fields.Char(string='Refund Electronic Device', size=20, readonly=True, copy=False)
    l10n_si_tax_reg_number_ref = fields.Char(string='Refund Invoice Number', size=20, readonly=True, copy=False)
    l10n_si_tax_reg_date_invoice_ref = fields.Datetime(string='Refund Invoice Issued', readonly=True, copy=False)

    l10n_si_tax_reg_source_model = fields.Char(string='Source Model')
    l10n_si_tax_reg_source_records = fields.Char(string='Source Record(s)')

    # TODO: pretvori api.one -> api.multi

    @api.constrains('l10n_si_tax_reg_premise_ref', 'l10n_si_tax_reg_device_ref', 'l10n_si_tax_reg_number_ref', 'l10n_si_tax_reg_date_invoice_ref')
    def _check_l10n_si_tax_reg_number_ref(self):
        i = 0
        if self.l10n_si_tax_reg_premise_ref:
            i += 1
        if self.l10n_si_tax_reg_device_ref:
            i += 1
        if self.l10n_si_tax_reg_number_ref:
            i += 1
        if self.l10n_si_tax_reg_date_invoice_ref:
            i += 1

        if i != 0 and i != 4:
            raise exceptions.ValidationError('Refund references must either be all set or none.')

    @api.constrains('l10n_si_tax_reg_source_model', 'l10n_si_tax_reg_source_records')
    def _check_l10n_si_tax_reg_source_model(self):
        if not self.l10n_si_tax_reg_source_model and not self.l10n_si_tax_reg_source_records:
            return

        if (not self.l10n_si_tax_reg_source_model and self.l10n_si_tax_reg_source_records) or (self.l10n_si_tax_reg_source_model and not self.l10n_si_tax_reg_source_records):
            raise exceptions.ValidationError(_('When main invoice has another source invoice, both source data must be provided!'))
        if not self.env['ir.model'].search_count([('model', '=', self.l10n_si_tax_reg_source_model)]):
            raise exceptions.ValidationError(_('No model with this name found!'))
        model = self.env[self.l10n_si_tax_reg_source_model]
        if not getattr(model, '_get_l10n_si_tax_reg_paid_state', None) or not callable(getattr(model, '_get_l10n_si_tax_reg_paid_state')):
            raise exceptions.ValidationError(_('Source model does not support the tax registration environment!'))

    def unlink(self):
        if any(i.l10n_si_tax_reg_sent for i in self):
            raise exceptions.Warning(_('You cannot delete an invoice which has already been registered at FURS. You should refund it instead.'))
        return super(L10nSiTaxRegInterface, self).unlink()

    def action_l10n_si_tax_reg_view_source_invoices(self):
        self.ensure_one()
        res = {}
        src_ids = self.l10n_si_tax_reg_source_records.split(',')
        if len(src_ids) < 1:
            return res

        src_model = self.env[self.l10n_si_tax_reg_source_model]
        res = src_model._get_l10n_si_tax_reg_view_action()
        #res['name'] = _('Source Invoice(s) for "%s"' % self.number or self.internal_number or self.name or self.reference or _('Unknown'))
        res['domain'] = "[('id', 'in', [%s])]" % ','.join(map(lambda x: str(x), src_ids))
        if (len(src_ids) > 1):
            return res

        res['res_id'] = int(src_ids[0])
        res['view_mode'] = 'form'
        i = 0
        for id, view in res['views']:
            if view == 'form':
                del(res['views'][i])
                res['views'].insert(0, (id, view))
                break
            i += 1

        return res

    def l10n_si_tax_reg_reexecute(self):
        if not self.l10n_si_tax_reg_sent or self.l10n_si_tax_reg_eor:
            raise exceptions.Warning(_('Cannot send registration request on finished or new invoices.'))

        return self.l10n_si_tax_reg_execute()

    def l10n_si_tax_reg_execute(self):
        self.ensure_one()
        if not self.l10n_si_tax_reg_premise_line_id or self.l10n_si_tax_reg_eor:
            return True

        rec = self._get_export_for_l10n_si_tax_reg()
        if 'TaxesPerSeller' not in rec or not rec['TaxesPerSeller'] or ('SellerTaxNumber' in rec['TaxesPerSeller'][0] and len(rec['TaxesPerSeller'][0]) == 1):
            return True

        val = {
            'l10n_si_tax_reg_msg_ident': '',
            'l10n_si_tax_reg_msg_dt': '',
            'l10n_si_tax_reg_premise': rec['InvoiceIdentifier']['BusinessPremiseID'],
            'l10n_si_tax_reg_device': rec['InvoiceIdentifier']['ElectronicDeviceID'],
            'l10n_si_tax_reg_number': rec['InvoiceIdentifier']['InvoiceNumber'],
            'l10n_si_tax_reg_zoi': '',
            'l10n_si_tax_reg_eor': '',
            'l10n_si_tax_reg_sent': True,
        }
        t = TmpCert()
        try:
            certs = t.record_open_write(self.l10n_si_tax_reg_premise_line_id.l10n_si_tax_reg_premise_id.company_id)
            s = SITaxReg(certs[0], certs[1], ca_certs=certs[2], dev=self.l10n_si_tax_reg_premise_line_id.l10n_si_tax_reg_premise_id.company_id.l10n_si_tax_reg_dev)
            # TODO: Switch to debug mode when we are using a developers environment?
            # s.set_debug(s.DEBUG_CLIENT)
            val['l10n_si_tax_reg_eor'] = s.issue_electronic_invoice(rec)
            val['l10n_si_tax_reg_zoi'] = s.get_zoi()
            val['l10n_si_tax_reg_msg_ident'] = s.get_message_id()
            val['l10n_si_tax_reg_msg_dt'] = fields.Datetime.to_string(s.get_request_datetime())
            self.write(val)
        except Exception as e:
            _logger.error(e)
            if not self.l10n_si_tax_reg_force_sent:
                raise e
            else:
                self.l10n_si_tax_reg_sent = True
                pass
        finally:
            t.rmtree()

        return True

    def _l10n_si_tax_reg_execute_auto_paid(self):
        if not self.l10n_si_tax_reg_premise_line_id or not self.l10n_si_tax_reg_premise_line_id.invoice_registered:
            return True
        if not self._get_l10n_si_tax_reg_paid_state():
            raise exceptions.Warning(_('Invoice not in paid state.'))
        return self.l10n_si_tax_reg_execute()

    def _get_export_for_l10n_si_tax_reg(self):
        self.ensure_one()
        refund = True if self.l10n_si_tax_reg_number_ref else False
        # NOTE: Not sure if payment, invoiced and returned amount should be
        # deducted by source invoice in case if it exists.
        res = {
            'TaxNumber': '',
            'IssueDateTime': self._get_export_for_l10n_si_tax_reg_issue_datetime_value(),
            'NumberingStructure': '',
            'InvoiceIdentifier': {
                'BusinessPremiseID': '',
                'ElectronicDeviceID': '',
                'InvoiceNumber': '',
            },
            'InvoiceAmount': float(self.with_context(l10n_si_tax_registry_refund=refund)._get_export_for_l10n_si_tax_reg_value_invoice_value()),
            'PaymentAmount': float(self.with_context(l10n_si_tax_registry_refund=refund)._get_export_for_l10n_si_tax_reg_payment_invoice_value()),
        }

        if self.l10n_si_tax_reg_premise_line_id:
            res['TaxNumber'] = int(self.l10n_si_tax_reg_premise_line_id.l10n_si_tax_reg_premise_id.company_id.vat.lstrip('SI'))
            res['NumberingStructure'] = self.l10n_si_tax_reg_premise_line_id.ir_sequence_type.upper()
            res['InvoiceIdentifier']['BusinessPremiseID'] = self.l10n_si_tax_reg_premise_line_id.l10n_si_tax_reg_premise_id.name
            res['InvoiceIdentifier']['ElectronicDeviceID'] = self.l10n_si_tax_reg_premise_line_id.name
            res['InvoiceIdentifier']['InvoiceNumber'] = self.l10n_si_tax_reg_premise_line_id._next()
        if self.l10n_si_tax_reg_number_ref:
            res['ReferenceInvoice'] = [{
                'ReferenceInvoiceIdentifier': {
                    'BusinessPremiseID': self.l10n_si_tax_reg_premise_ref,
                    'ElectronicDeviceID': self.l10n_si_tax_reg_device_ref,
                    'InvoiceNumber': self.l10n_si_tax_reg_number_ref,
                },
                'ReferenceInvoiceIssueDateTime': fields.Datetime.from_string(self.l10n_si_tax_reg_date_invoice_ref),
            }]

        val = self._get_export_for_l10n_si_tax_reg_customer_tax_value()
        if val:
            res['CustomerVATNumber'] = val
        val = float(self.with_context(l10n_si_tax_registry_refund=refund)._get_export_for_l10n_si_tax_reg_taxes_returns_value())
        if val:
            precision = dp.get_precision('Account')(self.env.cr)[1]
            res['ReturnsAmount'] = float(val)
            if not self._l10n_si_tax_reg_value_returns_inc_invoice:
                res['InvoiceAmount'] = float('.'.join(str(float_round(res['InvoiceAmount'] + res['ReturnsAmount'], precision_digits=precision)).split('.')))
            if not self._l10n_si_tax_reg_payment_returns_inc_invoice:
                res['PaymentAmount'] = float('.'.join(str(float_round(res['PaymentAmount'] + res['ReturnsAmount'], precision_digits=precision)).split('.')))
        val = self._get_export_for_l10n_si_tax_reg_behalf_invoice_value()
        if val:
            val = int(val)
            if val != res['TaxNumber']:
                if 'TaxesPerSeller' not in res:
                    res['TaxesPerSeller'] = [{}]

                res['TaxesPerSeller'][0]['SellerTaxNumber'] = val

        val = self.with_context(l10n_si_tax_registry_refund=refund)._get_export_for_l10n_si_tax_reg_taxes_value_calculated_against_source()
        if val:
            if 'TaxesPerSeller' not in res:
                res['TaxesPerSeller'] = [{}]
            res['TaxesPerSeller'][0].update(val)

        refund, val, isFor = self._get_export_for_l10n_si_tax_reg_issuer_invoice_value()
        if isFor:
            res['ForeignOperator'] = True
        else:
            res['OperatorTaxNumber'] = int(val) if val else res['TaxNumber']

        if self.l10n_si_tax_reg_sent:
            res['SubsequentSubmit'] = True

        val = self._get_export_for_l10n_si_tax_reg_msg_invoice_value()
        if val:
            res['SpecialNotes'] = val

        return res

    def _set_refund_reference_for_l10n_si_tax_reg(self, invoice_id):
        invoice = self.browse(invoice_id)
        vals = {
            'l10n_si_tax_reg_premise_ref': invoice.l10n_si_tax_reg_premise,
            'l10n_si_tax_reg_device_ref': invoice.l10n_si_tax_reg_device,
            'l10n_si_tax_reg_number_ref': invoice.l10n_si_tax_reg_number,
            'l10n_si_tax_reg_date_invoice_ref': invoice[self._l10n_si_tax_reg_issue_datetime],
        }
        for inv in self:
            inv.write(vals)

    def _get_export_for_l10n_si_tax_reg_issue_datetime(self):
        self.ensure_one()
        if not self._l10n_si_tax_reg_issue_datetime:
            raise NotImplementedError

        return self[self._l10n_si_tax_reg_issue_datetime]

    def _get_export_for_l10n_si_tax_reg_issue_datetime_value(self):
        self.ensure_one()
        res = self._get_export_for_l10n_si_tax_reg_issue_datetime()
        if not res:
            res = fields.Datetime.now()
            if self.env.context.get('l10n_si_tax_reg_issue_datetime', False):
                self[self._l10n_si_tax_reg_issue_datetime] = res
        return fields.Datetime.from_string(res)

    @api.returns('res.partner')
    def _get_export_for_l10n_si_tax_reg_customer_tax(self):
        self.ensure_one()
        if not self._l10n_si_tax_reg_customer_tax:
            return False

        return self[self._l10n_si_tax_reg_customer_tax]

    def _get_export_for_l10n_si_tax_reg_customer_tax_value(self):
        self.ensure_one()
        res = self._get_export_for_l10n_si_tax_reg_customer_tax()
        if not res:
            return ''
        return res.vat

    def _get_export_for_l10n_si_tax_reg_value_invoice(self):
        self.ensure_one()
        if not self._l10n_si_tax_reg_value_invoice:
            raise NotImplementedError

        # HRVOJE START
        # sep = '\n'+'*'*50 + '\n'
        # _logger.info(sep + 'Znesek: {0} {1}\nZnesek(compute): {2} {3}\nZnesek(compute_at_date): {4} {3}'.format(
        #     self[self._l10n_si_tax_reg_value_invoice],
        #     self['currency_id'].name,
        #     self[self._l10n_si_tax_reg_currency].compute(self[self._l10n_si_tax_reg_value_invoice], self[self._l10n_si_tax_reg_behalf_invoice].currency_id),
        #     self[self._l10n_si_tax_reg_behalf_invoice].currency_id.name,
        #     self[self._l10n_si_tax_reg_currency].compute_at_date(self[self._l10n_si_tax_reg_value_invoice], self[self._l10n_si_tax_reg_currency], self[self._l10n_si_tax_reg_behalf_invoice].currency_id, self[self._l10n_si_tax_reg_date_debt]))
        #              + sep)
        # compute_at_date(self, amount_from, currency_from, currency_to, date_at)

        if self._l10n_si_tax_reg_currency and self._l10n_si_tax_reg_behalf_invoice:
            if self[self._l10n_si_tax_reg_currency] != self[self._l10n_si_tax_reg_behalf_invoice].currency_id:
                # return self[self._l10n_si_tax_reg_currency].compute(self[self._l10n_si_tax_reg_value_invoice], self[self._l10n_si_tax_reg_behalf_invoice].currency_id)
                return self[self._l10n_si_tax_reg_currency].compute_at_date(self[self._l10n_si_tax_reg_value_invoice], self[self._l10n_si_tax_reg_currency], self[self._l10n_si_tax_reg_behalf_invoice].currency_id, self[self._l10n_si_tax_reg_date_debt])
        # HRVOJE END

        return self[self._l10n_si_tax_reg_value_invoice]

    def _get_export_for_l10n_si_tax_reg_value_invoice_value(self):
        self.ensure_one()
        res = self._get_export_for_l10n_si_tax_reg_value_invoice()
        if self.env.context.get('l10n_si_tax_registry_refund', False) and self._l10n_si_tax_reg_refund_negate:
            res = -res
        return str(res)

    def _get_export_for_l10n_si_tax_reg_payment_invoice(self):
        self.ensure_one()
        if self._l10n_si_tax_reg_payment_invoice:
            return self[self._l10n_si_tax_reg_payment_invoice]

        if self._l10n_si_tax_reg_value_invoice:
            # HRVOJE START
            if self._l10n_si_tax_reg_currency and self._l10n_si_tax_reg_behalf_invoice:
                if self[self._l10n_si_tax_reg_currency] != self[self._l10n_si_tax_reg_behalf_invoice].currency_id:
                    # return self[self._l10n_si_tax_reg_currency].compute(self[self._l10n_si_tax_reg_value_invoice], self[self._l10n_si_tax_reg_behalf_invoice].currency_id)
                    return self[self._l10n_si_tax_reg_currency].compute_at_date(self[self._l10n_si_tax_reg_value_invoice], self[self._l10n_si_tax_reg_currency], self[self._l10n_si_tax_reg_behalf_invoice].currency_id, self[self._l10n_si_tax_reg_date_debt])
            # HRVOJE END
            return self[self._l10n_si_tax_reg_value_invoice]

        raise NotImplemented

    def _get_export_for_l10n_si_tax_reg_payment_invoice_value(self):
        self.ensure_one()
        res = self._get_export_for_l10n_si_tax_reg_payment_invoice()
        if self.env.context.get('l10n_si_tax_registry_refund', False) and self._l10n_si_tax_reg_refund_negate:
            res = -res
        return str(res)

    @api.returns('res.partner')
    def _get_export_for_l10n_si_tax_reg_behalf_invoice(self):
        self.ensure_one()
        if not self._l10n_si_tax_reg_behalf_invoice:
            return False

        return self[self._l10n_si_tax_reg_behalf_invoice]

    def _get_export_for_l10n_si_tax_reg_behalf_invoice_value(self):
        self.ensure_one()
        res = self._get_export_for_l10n_si_tax_reg_behalf_invoice()
        if not res:
            return ''
        if not re.match('^SI[0-9]{8}$', res.vat):
            raise exceptions.Warning(_('Tax payer on whose behalf we are paying must have a valid Slovenian tax number.'))

        return res.vat.lstrip('SI')

    def _get_export_for_l10n_si_tax_reg_taxes(self):
        self.ensure_one()
        if not self._l10n_si_tax_reg_taxes:
            raise NotImplementedError

        return self[self._l10n_si_tax_reg_taxes]

    def _get_export_for_l10n_si_tax_reg_taxes_value(self):
        self.ensure_one()
        res = []
        rec = self._get_export_for_l10n_si_tax_reg_taxes()  # for account.invoice rec = self.invoice_line_ids
        for r in rec:  # for line in self.invoice_line_ids
            res.append({
                'account_tax_ids': r._get_export_for_l10n_si_tax_reg_account_tax_value(),  # line.invoice_line_tax_ids
                'qty': r._get_export_for_l10n_si_tax_reg_qty_value(),  # line.quantity
                'price': r._get_export_for_l10n_si_tax_reg_amount_value(),  # line.price_unit now in company currency
                'product_id': r._get_export_for_l10n_si_tax_reg_product_value(),  # line.product_id
                'partner_id': r._get_export_for_l10n_si_tax_reg_customer_value(),  # line.partner_id
            })

        return res

    def _get_export_for_l10n_si_tax_reg_taxes_returns_value(self):
        self.ensure_one()
        res = 0.0
        ResPartner = self.env['res.partner']
        rec = self._get_export_for_l10n_si_tax_reg_taxes()
        refund = self.env.context.get('l10n_si_tax_registry_refund', False)
        precision = str(dp.get_precision('Account')(self.env.cr)[1])

        for r in rec:  # for line in invoice_line_ids
            val = r._get_export_for_l10n_si_tax_reg_amount_value()  # line.price_unit in company currency
            if not val or (not refund and val > 0.0) or (refund and val < 0.0):  # no value returned or not a refund but val > 0 (remember these lines are supposed to be returns that lower the total on invoice) or it is a refund and the value is less than 0(again when refunding a negative line it becomes positive, so it shouldn't be negative)
                continue
            # _logger.info('THIS IS PARTNER: %r', r._get_export_for_l10n_si_tax_reg_customer_value() and ResPartner.browse(r._get_export_for_l10n_si_tax_reg_customer_value()) or None)

            res += float('.'.join(str(-float_round(r._get_export_for_l10n_si_tax_reg_account_tax_value().compute_all(price_unit=val,
                quantity=r._get_export_for_l10n_si_tax_reg_qty_value(), product=r._get_export_for_l10n_si_tax_reg_product_value() or None,
                partner=r._get_export_for_l10n_si_tax_reg_customer_value() and ResPartner.browse(r._get_export_for_l10n_si_tax_reg_customer_value()) or None)['total_included'], precision_digits=precision)).split('.'))) or 0.0

        return str(res)

    def _get_export_for_l10n_si_tax_reg_taxes_value_calculated(self, data):
        res = {}
        rec = {}
        tmp = {}
        ResPartner = self.env['res.partner']
        precision = dp.get_precision('Account')(self.env.cr)[1]
        if precision > 2:
            _logger.warning(_('Slovenian tax registry does not support decimal value rounding larger than 2 digits.'))
        # _logger.info('\n*---------\n'
        #              '*DATA: %s\n'
        #              '*------------\n', data)
        for d in data:
            # _logger.info('\n*---------\n'
            #              '*DATA PART: %s\n'
            #              '*------------\n', d)
            if 'account_tax_ids' not in d or not d['account_tax_ids']:
                continue

            for t in d['account_tax_ids']:
                if t.id in rec:
                    continue

                if _ODOO_TAX_TYPE_2_SI_TAX_TYPE[t.l10n_si_tax_reg_tax_type][1] and t.amount_type != 'percent':
                    raise exceptions.Warning(_('Slovenian tax registry supports only percent-based calculation on certain taxes.'))
                # rec[t.id] = (t.l10n_si_tax_reg_tax_type, float_round(t.amount * 100, precision_digits=precision))  # amount in Odoo 8 is 0.22 for 22% in Odoo 9 is 22 for 22%
                rec[t.id] = (t.l10n_si_tax_reg_tax_type, float_round(t.amount, precision_digits=precision))
                # _logger.info('\n*---------\n'
                #              '*TAX DICT: %s\n'
                #              '*---------\n', rec)

                # TODO: Set correct currency
            taxes = d['account_tax_ids'].compute_all(d['price'], quantity=d['qty'], product=d['product_id'] or None, partner=d['partner_id'] and ResPartner.browse(d['partner_id']) or None)
            # _logger.info('\n*---------\n'
            #              '*TAXES: %s\n'
            #              '*---------\n', taxes)

            # XXX: Written poorly. Make a better rewrite.
            for t in taxes['taxes']:
                type = _ODOO_TAX_TYPE_2_SI_TAX_TYPE[rec[t['id']][0]]
                if type[0] not in tmp:
                    tmp[type[0]] = {} if type[1] else 0.0

                if type[1]:
                    if rec[t['id']][1] not in tmp[type[0]]:
                        tmp[type[0]][rec[t['id']][1]] = [0.0, 0.0, type[1][0], type[1][1], type[1][2]]

                    tmp[type[0]][rec[t['id']][1]][0] += float('.'.join(str(float_round(d['qty'] * d['price'], precision_digits=precision)).split('.')))
                    tmp[type[0]][rec[t['id']][1]][1] += t['amount']
                else:
                    tmp[type[0]][rec[t['id']][1]] += t['amount']

        for k, t in tmp.iteritems():
            if isinstance(t, dict):
                res[k] = []
                for m, d in t.iteritems():
                    res[k].append({
                        d[2]: m,
                        d[3]: float('.'.join(str(float_round(d[0], precision_digits=precision)).split('.'))),
                        d[4]: float('.'.join(str(float_round(d[1], precision_digits=precision)).split('.'))),
                    })
            else:
                res[k] = float('.'.join(str(float_round(t, precision_digits=precision)).split('.')))
        return res

    def _get_export_for_l10n_si_tax_reg_taxes_value_calculated_against_source(self):
        self.ensure_one()
        val = self._get_export_for_l10n_si_tax_reg_taxes_value()
        val = self._get_export_for_l10n_si_tax_reg_taxes_value_calculated(val)

        src_rec = self._check_and_get_l10n_si_tax_reg_src_records()
        if not src_rec:
            return val

        taxSignList = set()
        for t in _ODOO_TAX_TYPE_2_SI_TAX_TYPE.values():
            if len(t[1]) > 0:
                taxSignList.add(t[1][0])
        taxSignList = list(taxSignList)

        src_val = {}
        if len(src_rec) == 1:
            src_val = src_rec[0]._get_export_for_l10n_si_tax_reg_taxes_value()
            src_val = src_rec[0]._get_export_for_l10n_si_tax_reg_taxes_value_calculated(src_val)
        else:
            for s in src_rec:
                val_src = s._get_export_for_l10n_si_tax_reg_taxes_value()
                val_src = s._get_export_for_l10n_si_tax_reg_taxes_value_calculated(val_src)
                for i, v in val_src.iteritems():
                    if i not in src_val:
                        src_val[i] = [] if isinstance(v, list) else 0.0
                    if isinstance(v, list):
                        for n, t in enumerate(v):
                            taxSign = ''
                            for l in t.keys():
                                if l in taxSignList:
                                    taxSign = l
                                    break
                            # TODO: Scenario when sign is not found.
                            # if not taxSign:
                            found = False
                            for m, e in enumerate(src_val[i]):
                                if e[taxSign] == t[taxSign]:
                                    for x, r in t.iteritems():
                                        if x == taxSign:
                                            continue
                                        src_val[i][m][x] += r
                                    found = True
                                    break
                            if not found:
                                src_val[i].append(t)
                    else:
                        src_val[i] += v

        for i, v in val.iteritems():
            if i not in src_val:
                continue
            if isinstance(v, list):
                for n, t in enumerate(v):
                    taxSign = ''
                    for l in t.keys():
                        if l in taxSignList:
                            taxSign = l
                            break
                    for m in src_val[i]:
                        if m[taxSign] == t[taxSign]:
                            for l in m.keys():
                                if l == taxSign:
                                    continue
                                val[i][n][l] -= m[l]
                            break
            else:
                val[i] -= src_val[i]

        sanitized_val = {}
        for i, v in val.iteritems():
            if isinstance(v, list):
                for n, t in enumerate(v):
                    for k in t.keys():
                        if k in taxSignList:
                            continue
                        if t[k] != 0.0:
                            if i not in sanitized_val:
                                sanitized_val[i] = []
                            sanitized_val[i].append(t)
                            break
            elif v != 0.0:
                sanitized_val[i] = v

        return sanitized_val

    @api.returns('res.partner')
    def _get_export_for_l10n_si_tax_reg_issuer_invoice(self):
        self.ensure_one()
        if not self._l10n_si_tax_reg_issuer_invoice:
            return False

        return self[self._l10n_si_tax_reg_issuer_invoice]

    def _get_export_for_l10n_si_tax_reg_issuer_invoice_value(self):
        self.ensure_one()
        res = self._get_export_for_l10n_si_tax_reg_issuer_invoice()
        if not res:
            return ('', '', False)
        if not res.vat or res.vat == '':
            raise exceptions.Warning(_('Invoice issuer must have a tax number.'))
        if not re.match('^SI[0-9]{8}$', res.vat):
            return (res.name, '', True)

        return (res.name, res.vat.lstrip('SI'), False)

    def _get_export_for_l10n_si_tax_reg_msg_invoice(self):
        self.ensure_one()
        if not self._l10n_si_tax_reg_msg_invoice:
            return ''

        return self[self._l10n_si_tax_reg_msg_invoice]

    def _get_export_for_l10n_si_tax_reg_msg_invoice_value(self):
        self.ensure_one()
        res = self._get_export_for_l10n_si_tax_reg_msg_invoice()
        if not res:
            return ''
        return res

    def _check_and_get_l10n_si_tax_reg_src_records(self):
        self.ensure_one()
        if not self.l10n_si_tax_reg_source_model or not self.l10n_si_tax_reg_source_records:
            return []

        src_ids = self.l10n_si_tax_reg_source_records.split(',')
        src_rec = self.env[self.l10n_si_tax_reg_source_model].browse([int(x) for x in src_ids])
        if len(src_ids) != len(src_rec):
            raise exceptions.Warning(_('Number of existing source invoices does not match the quantity assigned on the original invoice!'))
        if not all(s.l10n_si_tax_reg_sent for s in src_rec):
            raise exceptions.Warning(_('Source invoice(s) haven\'t been registered yet!'))
        return src_rec

    @api.model
    def _get_l10n_si_tax_reg_view_action(self):
        if not self._l10n_si_tax_reg_view_action or not self._l10n_si_tax_reg_module_name:
            res = self.env['ir.actions.act_window'].search([('res_model', '=', self._name)], limit=1)
            if not res:
                raise NotImplementedError
            res = self.env['ir.model.data'].search([('model', '=', 'ir.actions.act_window'), ('res_id', '=', res.id)], limit=1)
            if not res:
                raise NotImplementedError
            module = res.module
            res = res.name
        else:
            res = self._l10n_si_tax_reg_view_action
            module = self._l10n_si_tax_reg_module_name

        return self.env['ir.actions.act_window'].for_xml_id(module, res)

    def _get_l10n_si_tax_reg_paid_state(self):
        for rec in self:
            if isinstance(self._l10n_si_tax_reg_paid_state_value, list):
                if rec[self._l10n_si_tax_reg_paid_state_field] not in self._l10n_si_tax_reg_paid_state_value:
                    return False
            else:
                if rec[self._l10n_si_tax_reg_paid_state_field] != self._l10n_si_tax_reg_paid_state_value:
                    return False

        return True

    def get_report_for_l10n_si_tax_reg_barcode(self):
        self.ensure_one()
        res = ''

        tmp = self.l10n_si_tax_reg_zoi and str(int(self.l10n_si_tax_reg_zoi.replace('-', ''), 16)) or ''
        res += tmp.zfill(39)

        tmp = self.l10n_si_tax_reg_premise_line_id and self.l10n_si_tax_reg_premise_line_id.l10n_si_tax_reg_premise_id.company_id.vat.lstrip('SI') or ''
        res += tmp.zfill(8)

        tmp = self[self._l10n_si_tax_reg_issue_datetime] and fields.Datetime.context_timestamp(self, fields.Datetime.from_string(self[self._l10n_si_tax_reg_issue_datetime])).strftime('%y%m%d%H%M%S') or ''
        res += tmp.zfill(12)

        tmp = 0
        for s in res:
            tmp += int(s)

        return res + str(tmp % 10)


class L10nSiTaxRegInterfaceLine(models.AbstractModel):
    _name = 'l10n_si_tax_reg.interface.line'

    _l10n_si_tax_reg_account_tax = ''
    _l10n_si_tax_reg_qty = ''
    _l10n_si_tax_reg_amount = ''
    _l10n_si_tax_reg_customer = ''
    _l10n_si_tax_reg_product = ''
    _l10n_si_tax_reg_behalf_invoice = ''
    _l10n_si_tax_reg_currency = ''
    _l10n_si_tax_reg_date_debt = ''

    _l10n_si_tax_reg_refund_negate = True

    _l10n_si_tax_reg_discount_percent = ''
    _l10n_si_tax_reg_discount_fixed = ''

    @api.returns('account.tax')
    def _get_export_for_l10n_si_tax_reg_account_tax(self):
        self.ensure_one()
        if not self._l10n_si_tax_reg_account_tax:
            raise NotImplementedError

        return _resolve_many_2_one_field(self, self._l10n_si_tax_reg_account_tax)

    def _get_export_for_l10n_si_tax_reg_account_tax_value(self):
        self.ensure_one()
        return self._get_export_for_l10n_si_tax_reg_account_tax()

    def _get_export_for_l10n_si_tax_reg_qty(self):
        self.ensure_one()
        if not self._l10n_si_tax_reg_qty:
            return False

        return self[self._l10n_si_tax_reg_qty]

    def _get_export_for_l10n_si_tax_reg_qty_value(self):
        self.ensure_one()
        res = self._get_export_for_l10n_si_tax_reg_qty()
        if not res:
            return 1

        return abs(res)

    def _get_export_for_l10n_si_tax_reg_amount(self):
        self.ensure_one()
        if not self._l10n_si_tax_reg_amount:
            raise NotImplementedError
        # HRVOJE START TODO: najdi način kako dobit datum opravljene storitve tudi iz POS računa! to zna bit da ne bo delalo za POS!!!
        if self._l10n_si_tax_reg_currency and self._l10n_si_tax_reg_behalf_invoice:
            if self[self._l10n_si_tax_reg_currency] != self[self._l10n_si_tax_reg_behalf_invoice].currency_id:
                # return self[self._l10n_si_tax_reg_currency].compute(self[self._l10n_si_tax_reg_amount], self[self._l10n_si_tax_reg_behalf_invoice].currency_id)
                return self[self._l10n_si_tax_reg_currency].compute_at_date(self[self._l10n_si_tax_reg_amount], self[self._l10n_si_tax_reg_currency], self[self._l10n_si_tax_reg_behalf_invoice].currency_id, self._l10n_si_tax_reg_date_debt)
        # HRVOJE END

        return self[self._l10n_si_tax_reg_amount]

    def _get_export_for_l10n_si_tax_reg_amount_value(self):
        self.ensure_one()
        res = self._get_export_for_l10n_si_tax_reg_amount()  # line.price_unit
        if self._l10n_si_tax_reg_discount_percent:
            if self[self._l10n_si_tax_reg_discount_percent]:
                res = res * (1 - (self[self._l10n_si_tax_reg_discount_percent] or 0.0) / 100.0)
        elif self._l10n_si_tax_reg_discount_fixed and self[self._l10n_si_tax_reg_discount_fixed]:
            res = res - self[self._l10n_si_tax_reg_discount_fixed]

        if self.env.context.get('l10n_si_tax_registry_refund', False) and self._l10n_si_tax_reg_refund_negate:
            res = -res

        return res

    @api.returns('res.partner')
    def _get_export_for_l10n_si_tax_reg_customer(self):
        self.ensure_one()
        if not self._l10n_si_tax_reg_customer:
            return False

        # return _resolve_many_2_one_field(self, self._l10n_si_tax_reg_customer)
        rec = _resolve_many_2_one_field(self, self._l10n_si_tax_reg_customer)
        return rec

    def _get_export_for_l10n_si_tax_reg_customer_value(self):
        self.ensure_one()
        res = self._get_export_for_l10n_si_tax_reg_customer()
        if not res:
            return 0

        return res.id

    @api.returns('product.product')
    def _get_export_for_l10n_si_tax_reg_product(self):
        self.ensure_one()
        if not self._l10n_si_tax_reg_product:
            return False

        return self[self._l10n_si_tax_reg_product]

    def _get_export_for_l10n_si_tax_reg_product_value(self):
        self.ensure_one()
        res = self._get_export_for_l10n_si_tax_reg_product()
        if not res:
            return 0

        return res.id
